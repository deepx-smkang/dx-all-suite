ARG BASE_IMAGE_NAME=ubuntu
ARG OS_VERSION=24.04
ARG TAG_NAME=${OS_VERSION}
ARG INSTALL_BASE_IMAGE=alpine:latest
FROM ${INSTALL_BASE_IMAGE} AS install
USER root

# Install tar if using ubuntu base (alpine has it by default)
RUN if command -v apt-get >/dev/null 2>&1; then \
        apt-get update && apt-get install -y tar && rm -rf /var/lib/apt/lists/*; \
    fi

# COPY and EXTRACT 'dx-com' for using option '--strip-components=1'
WORKDIR /deepx/dx-compiler/dx_com
ARG FILE_DXCOM
COPY ${FILE_DXCOM} /deepx/dx-compiler/dx_com

RUN tar_file=$(ls *.tar.gz) && \
    first_entry=$(tar -tzf "$tar_file" | head -n 1) && \
    normalized_entry="${first_entry#./}" && \
    if echo "$normalized_entry" | grep -q '/'; then \
        if echo "$first_entry" | grep -q '^./'; then \
            echo "Detected top-level directory with ./ prefix. Using --strip-components=2"; \
            tar -xzf "$tar_file" --strip-components=2 -C .; \
        else \
            echo "Detected top-level directory. Using --strip-components=1"; \
            tar -xzf "$tar_file" --strip-components=1 -C .; \
        fi; \
    else \
        echo "No top-level directory. Extracting as-is"; \
        tar -xzf "$tar_file" -C .; \
    fi && \
    rm -f "$tar_file"

WORKDIR /deepx/dx-compiler/dx_tron
ARG FILE_DXTRON
COPY ${FILE_DXTRON} /deepx/dx-compiler/dx_tron

RUN tar_file=$(ls *.tar.gz) && \
    first_entry=$(tar -tzf "$tar_file" | head -n 1) && \
    normalized_entry="${first_entry#./}" && \
    if echo "$normalized_entry" | grep -q '/'; then \
        if echo "$first_entry" | grep -q '^./'; then \
            echo "Detected top-level directory with ./ prefix. Using --strip-components=2"; \
            tar -xzf "$tar_file" --strip-components=2 -C .; \
        else \
            echo "Detected top-level directory. Using --strip-components=1"; \
            tar -xzf "$tar_file" --strip-components=1 -C .; \
        fi; \
    else \
        echo "No top-level directory. Extracting as-is"; \
        tar -xzf "$tar_file" -C .; \
    fi && \
    rm -f "$tar_file"

# COPY 'scripts' and 'getting-started'
COPY scripts /deepx/scripts
COPY getting-started /deepx/getting-started
ENV DX_CONTAINER_MODE=true
RUN /deepx/getting-started/compiler-clean.sh

###
FROM ${BASE_IMAGE_NAME}:${TAG_NAME}

USER root

# ARG must be re-declared after FROM to be available in RUN commands
ARG BASE_IMAGE_NAME=ubuntu

ARG TZ=Asia/Seoul
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ >/etc/timezone

ARG DEBIAN_FRONTEND=noninteractive
ENV PATH="/usr/local/bin:${PATH}"

### update apt repo
RUN apt-get update && apt-get install -y \
    software-properties-common

RUN if [ "${BASE_IMAGE_NAME}" = "ubuntu" ]; then \
    add-apt-repository universe && \
    add-apt-repository multiverse && \
    apt-get update; \
  fi

### install utils
RUN apt-get update && apt-get install -y \
        tzdata \
        git vim sudo \
        lsb-release

# X11 forwarding and xcb
RUN apt-get install -y x11-apps libx11-6 xauth libxext6 libxrender1 libxtst6 libxi6 libxcb-xinerama0

# for setting ssl issue on intranet
# only used 'USE_INTRANET=true'
ARG USE_INTRANET=false
ARG CA_FILE_NAME="dummy.crt"
COPY ${CA_FILE_NAME} /usr/local/share/ca-certificates/
RUN if [ "$USE_INTRANET" = "true" ]; then \
      git config --global http.sslVerify false && \
      update-ca-certificates ; \
    else \
      echo "Skipping intranet SSL setup"; \
    fi

# Install dependencies for dx-compiler
# Setup Python (minimum 3.8)
#   - Detect system Python first, install MIN_PY_VERSION if system Python is lower
#   - Unified installation flow: system python → apt → source build fallback
#   - Ubuntu 20.04, 22.04, 24.04 supported
ENV MIN_PY_VERSION=3.8
ARG TARGET_INSTALL_PY_VERSION=""
RUN set -x && \
    echo "Detecting system Python and checking minimum version requirement..." && \
    MIN_MAJOR=$(echo "${MIN_PY_VERSION}" | cut -d. -f1) && \
    MIN_MINOR=$(echo "${MIN_PY_VERSION}" | cut -d. -f2) && \
    DX_PYTHON_EXEC="" && \
    NEED_INSTALL="false" && \
    if command -v python3 >/dev/null 2>&1; then \
        SYS_PY_VERSION=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}')" 2>/dev/null || echo "0.0.0") && \
        SYS_MAJOR=$(echo "${SYS_PY_VERSION}" | cut -d. -f1) && \
        SYS_MINOR=$(echo "${SYS_PY_VERSION}" | cut -d. -f2) && \
        echo "System Python detected: ${SYS_PY_VERSION}" && \
        if [ "$SYS_MAJOR" -gt "$MIN_MAJOR" ] || { [ "$SYS_MAJOR" -eq "$MIN_MAJOR" ] && [ "$SYS_MINOR" -ge "$MIN_MINOR" ]; }; then \
            echo "System Python ${SYS_PY_VERSION} meets minimum requirement (>= ${MIN_PY_VERSION})" && \
            SYS_PY_MAJOR_MINOR="${SYS_MAJOR}.${SYS_MINOR}" && \
            echo "Installing python${SYS_PY_MAJOR_MINOR}-dev and python${SYS_PY_MAJOR_MINOR}-venv packages..." && \
            apt-get update && \
            apt-get install -y python${SYS_PY_MAJOR_MINOR}-dev python${SYS_PY_MAJOR_MINOR}-venv || \
            apt-get install -y python3-dev python3-venv && \
            DX_PYTHON_EXEC="python3"; \
        else \
            echo "System Python ${SYS_PY_VERSION} is lower than minimum ${MIN_PY_VERSION}, need to install..." && \
            NEED_INSTALL="true"; \
        fi; \
    else \
        echo "No system Python found, need to install..." && \
        NEED_INSTALL="true"; \
    fi && \
    if [ -n "${TARGET_INSTALL_PY_VERSION}" ]; then \
        echo "Specific version requested: ${TARGET_INSTALL_PY_VERSION}, will install..." && \
        NEED_INSTALL="true" && \
        DX_PYTHON_EXEC=""; \
    fi && \
    if [ "${NEED_INSTALL}" = "true" ]; then \
        if [ -z "${TARGET_INSTALL_PY_VERSION}" ]; then \
            TARGET_INSTALL_PY_VERSION="${MIN_PY_VERSION}.0"; \
            echo "Using minimum version for installation: ${TARGET_INSTALL_PY_VERSION}"; \
        fi && \
        PY_MAJOR_MINOR=$(echo "${TARGET_INSTALL_PY_VERSION}" | cut -d. -f1,2) && \
        if [ "${BASE_IMAGE_NAME}" = "ubuntu" ] && { [ "$(lsb_release -rs)" = "24.04" ] || [ "$(lsb_release -rs)" = "22.04" ] || [ "$(lsb_release -rs)" = "20.04" ]; }; then \
            echo "Supported OS: ${BASE_IMAGE_NAME} $(lsb_release -rs)" && \
            apt-get update && \
            if [ "${BASE_IMAGE_NAME}" = "ubuntu" ]; then \
                echo "Adding deadsnakes PPA for Ubuntu..." && \
                apt-get install -y software-properties-common gnupg gpg-agent ca-certificates && \
                add-apt-repository -y ppa:deadsnakes/ppa || echo "PPA add failed, continuing..." && \
                apt-get update || true; \
            fi && \
            echo "Checking if python${PY_MAJOR_MINOR} packages are available via apt..." && \
            MAIN_PKG=$(apt-cache search "^python${PY_MAJOR_MINOR}$" 2>/dev/null | grep -c "^python${PY_MAJOR_MINOR} " || echo "0") && \
            DEV_PKG=$(apt-cache search "^python${PY_MAJOR_MINOR}-dev$" 2>/dev/null | grep -c "^python${PY_MAJOR_MINOR}-dev " || echo "0") && \
            VENV_PKG=$(apt-cache search "^python${PY_MAJOR_MINOR}-venv$" 2>/dev/null | grep -c "^python${PY_MAJOR_MINOR}-venv " || echo "0") && \
            echo "Installing generic python3-dev and python3-venv packages (base requirement)..." && \
            apt-get install -y python3-dev python3-venv && \
            if [ "$MAIN_PKG" -gt 0 ] && [ "$DEV_PKG" -gt 0 ] && [ "$VENV_PKG" -gt 0 ]; then \
                echo "python${PY_MAJOR_MINOR} packages available via apt, installing..." && \
                apt-get install -y python${PY_MAJOR_MINOR} python${PY_MAJOR_MINOR}-dev python${PY_MAJOR_MINOR}-venv && \
                DX_PYTHON_EXEC="python${PY_MAJOR_MINOR}"; \
            else \
                echo "python${PY_MAJOR_MINOR} not available via apt (main:$MAIN_PKG, dev:$DEV_PKG, venv:$VENV_PKG), will use source build..."; \
            fi && \
            if [ -z "${DX_PYTHON_EXEC}" ]; then \
                echo "Installing python ${TARGET_INSTALL_PY_VERSION} via source build..." && \
                apt-get install -y --no-install-recommends \
                    build-essential \
                    wget \
                    curl \
                    ca-certificates \
                    libssl-dev \
                    zlib1g-dev \
                    libncurses5-dev \
                    libncursesw5-dev \
                    libreadline-dev \
                    libsqlite3-dev \
                    libgdbm-dev \
                    libdb5.3-dev \
                    libbz2-dev \
                    libexpat1-dev \
                    liblzma-dev \
                    tk-dev \
                    libffi-dev \
                    uuid-dev && \
                wget --no-check-certificate https://www.python.org/ftp/python/${TARGET_INSTALL_PY_VERSION}/Python-${TARGET_INSTALL_PY_VERSION}.tgz && \
                tar xzf Python-${TARGET_INSTALL_PY_VERSION}.tgz && \
                cd Python-${TARGET_INSTALL_PY_VERSION} && \
                ./configure --enable-optimizations && \
                make -j$(nproc) && \
                make altinstall && \
                cd .. && \
                rm -rf Python-${TARGET_INSTALL_PY_VERSION}* && \
                DX_PYTHON_EXEC="python${PY_MAJOR_MINOR}"; \
            fi; \
        else \
            echo "Unsupported OS: ${BASE_IMAGE_NAME} $(lsb_release -rs)" && exit 1; \
        fi; \
    fi && \
    if [ -z "${DX_PYTHON_EXEC}" ]; then \
        echo "Failed to determine Python executable" && exit 1; \
    fi && \
    echo "Python ready: ${DX_PYTHON_EXEC} ($(${DX_PYTHON_EXEC} --version 2>&1))" && \
    echo "Set up Virtual Environment..." && \
    ${DX_PYTHON_EXEC} -m venv /venv-dxnn && \
    . /venv-dxnn/bin/activate && \
    echo "Upgrade pip wheel setuptools..." && \
    if [ "${BASE_IMAGE_NAME}" = "ubuntu" ]; then \
        OS_VERSION=$(lsb_release -rs) && \
        echo "*** OS_VERSION(${OS_VERSION}) ***" && \
        if [ "$OS_VERSION" = "24.04" ]; then \
            apt-get update && apt-get install -y --no-install-recommends \
                libgl1-mesa-dev libglib2.0-0 make \
                libfuse2 libayatana-appindicator3-1; \
        elif [ "$OS_VERSION" = "22.04" ]; then \
            apt-get update && apt-get install -y --no-install-recommends \
                libgl1-mesa-dev libglib2.0-0 make \
                libfuse2 libappindicator3-1 libgconf-2-4; \
        elif [ "$OS_VERSION" = "20.04" ]; then \
            apt-get update && apt-get install -y --no-install-recommends \
                libgl1-mesa-dev libgl1-mesa-glx libglib2.0-0 make \
                libfuse2 libappindicator1 libgconf-2-4; \
        else \
            echo "Unsupported Ubuntu version: $OS_VERSION" && exit 1; \
        fi; \
    else \
        echo "Unsupported base image: ${BASE_IMAGE_NAME}" && exit 1; \
    fi

# Install build tools and libraries
RUN set -x && \
    apt-get update && apt-get install -y --no-install-recommends \
        libssl-dev \
        wget \
        openssl \
        build-essential \
        zlib1g-dev \
        patchelf \
        libffi-dev \
        ca-certificates \
        libbz2-dev \
        liblzma-dev \
        libncursesw5-dev \
        libsqlite3-dev \
        tk-dev \
        libgdbm-dev \
        libc6-dev \
        libncurses5-dev \
        libnss3-dev \
        ccache \
        fuse libxss1 libxtst6 libnss3 \
        libcanberra-gtk-module libcanberra-gtk3-module \
        software-properties-common \
        vim fim

RUN apt-get update && \
    apt-get install -y \
        xdg-utils && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

ARG HOST_UID
ARG HOST_GID
ARG TARGET_USER
ARG TARGET_HOME

# Set default values (in case values are not provided at build time)
ENV HOST_UID=${HOST_UID:-1000}
ENV HOST_GID=${HOST_GID:-1000}
ENV TARGET_USER=${TARGET_USER:-deepx}
ENV TARGET_HOME=${TARGET_HOME:-/deepx}

# UID/GID based user processing
RUN set -eux; \
    if getent passwd "$HOST_UID" > /dev/null; then \
        EXISTING_USER=$(getent passwd "$HOST_UID" | cut -d: -f1); \
        usermod -l "$TARGET_USER" -d "$TARGET_HOME" -m "$EXISTING_USER"; \
        EXISTING_GROUP=$(getent group "$HOST_GID" | cut -d: -f1); \
        groupmod -n "$TARGET_USER" "$EXISTING_GROUP"; \
    else \
        groupadd -g "$HOST_GID" "$TARGET_USER" || true; \
        useradd -u "$HOST_UID" -g "$HOST_GID" -d "$TARGET_HOME" -s /bin/bash "$TARGET_USER"; \
    fi

# Copy init script for workspace permissions
COPY docker/init-workspace.sh /usr/local/bin/init-workspace.sh
RUN chmod +x /usr/local/bin/init-workspace.sh

# Copy dx_com and dx_tron
COPY --from=install /deepx /deepx

RUN chown -R "$HOST_UID:$HOST_GID" "$TARGET_HOME"

# set default password
RUN echo "deepx:deepx" | chpasswd

# add sudo group
RUN groupadd -g "$HOST_GID" "$TARGET_USER" || true; \
    usermod -aG sudo "$TARGET_USER"; \
    echo "$TARGET_USER ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers;

# Install DX-COM wheel package for the current Python version (before switching to non-root user)
# For Python 3.8, manually install onnxruntime 1.18.0 from direct URL (PyPI doesn't support it)
RUN set -ex; \
    . /venv-dxnn/bin/activate; \
    PYTHON_VERSION_TAG=$(python3 -c "import sys; print(f'cp{sys.version_info.major}{sys.version_info.minor}')"); \
    echo "Detected Python version tag: ${PYTHON_VERSION_TAG}"; \
    if [ "${PYTHON_VERSION_TAG}" = "cp38" ]; then \
        echo "Python 3.8 detected: Upgrading pip and installing onnxruntime 1.18.0 from direct URL..."; \
        pip3 install --upgrade pip; \
        pip3 install https://files.pythonhosted.org/packages/1b/74/02cb1f6fcbadc094c98c49aff8571e7c576bdb4015c01507c385285b5bed/onnxruntime-1.18.0-cp38-cp38-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl; \
    fi; \
    MATCHING_WHEEL=$(find /deepx/dx-compiler/dx_com -name "*-${PYTHON_VERSION_TAG}-*.whl" -print -quit); \
    if [ -z "$MATCHING_WHEEL" ]; then \
        echo "ERROR: No wheel file compatible with Python ${PYTHON_VERSION_TAG} found."; \
        ls -la /deepx/dx-compiler/dx_com/*.whl || echo "No wheel files found"; \
        exit 1; \
    fi; \
    echo "Found compatible wheel file: $(basename "$MATCHING_WHEEL")"; \
    pip3 install "$MATCHING_WHEEL"

# Install DX-Tron package for debian-based systems (with architecture detection)
RUN set -x && \
    ARCH=$(dpkg --print-architecture 2>/dev/null || uname -m) && \
    case "$ARCH" in \
        amd64|x86_64) ARCH="amd64" ;; \
        arm64|aarch64) ARCH="arm64" ;; \
    esac && \
    echo "Detected architecture: ${ARCH}" && \
    apt-get update && \
    apt install -y /deepx/dx-compiler/dx_tron/dxtron_*_${ARCH}.deb

USER $TARGET_USER
WORKDIR $TARGET_HOME

RUN echo "source /venv-dxnn/bin/activate" >> $TARGET_HOME/.bashrc

ENTRYPOINT ["/usr/local/bin/init-workspace.sh"]
CMD ["tail", "-f", "/dev/null"]
